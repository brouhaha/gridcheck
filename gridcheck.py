#!/usr/bin/env python3

# grid_check.py: Check that the holes specified in an Excellon drill file
# are on a grid, excluding vias
# Copyright 2020 Eric Smith
# SPDX-License-Identifier: GPL-3.0-only

#-----------------------------------------------------------------------------
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.
#-----------------------------------------------------------------------------

# This has only been tested with Excellon files generated by the
# Eagle CAD 7.7 CAM processor, and probably won't work with other sources.


import argparse
from dataclasses import dataclass
from decimal import *
import re
import sys
from typing import Dict, List


int_re = re.compile('[-+]?[0-9]+')

float_re = re.compile('[-+]?[0-9]+(\.[0-9]+)?')


def extract_int(l: str) -> (int, str):
    m = int_re.match(l)
    assert m
    s = m.group()
    return int(s), l[len(s):]


def extract_dec(l: str) -> (Decimal, str):
    m = float_re.match(l)
    assert m
    s = m.group()
    return Decimal(s), l[len(s):]


@dataclass
class Tool:
    num: int
    dia: Decimal


@dataclass
class Coordinate:
    x: Decimal
    y: Decimal


@dataclass
class Excellon:
    tools: Dict[int, Tool]
    holes: Dict[int, List[Coordinate]]

    def comment(self, l):
        pass

    def cmd_m30(self, l):
        assert self.started
        self.started = False

    def cmd_m48(self, l):
        self.started = True

    def cmd_m71(self, l):
        assert self.started
        self.inch = False

    def cmd_m72(self, l):
        assert self.started
        self.inch = True

    dispatch_m = {
        30: cmd_m30,
        48: cmd_m48,
        71: cmd_m71,
        72: cmd_m72
    }

    def cmd_m(self, l):
        cmd_num, l = extract_int(l)
        assert not l
        self.dispatch_m[cmd_num](self, l)
        

    def cmd_t(self, l):
        assert self.started
        tool_num, l = extract_int(l)
        assert 1 <= tool_num <= 99
        if not l:
            assert tool_num in self.tools
            self.current_tool_num = tool_num
            return
        assert l[0] == 'C'
        l = l[1:]
        tool_dia, l = extract_dec(l)
        assert not l
        assert tool_num not in self.tools
        self.tools[tool_num] = Tool(tool_num, tool_dia)
        self.holes[tool_num] = []

    def cmd_x(self, l):
        assert self.started
        x, l = extract_dec(l)
        assert l[0] == 'Y'
        y, l = extract_dec(l[1:])
        assert not l
        coord = Coordinate(x / self.digits_scaling, y / self.digits_scaling)
        self.holes[self.current_tool_num].append(coord)
        #print(f'tool {self.current_tool_num} hole {coord}')


    dispatch = { '%': comment,
                 'M': cmd_m,
                 'T': cmd_t,
                 'X': cmd_x
    }

    def parse(self, file):
        self.started = False
        while True:
            l = file.readline()
            if not l:
                break
            l = l.strip()
            self.dispatch[l[0]](self, l[1:])
        

    def __init__(self, digits = 5, file = None):
        self.digits = digits
        self.digits_scaling = Decimal(10) ** self.digits
        self.tools = { }
        self.holes = { }

        if file is not None:
            self.parse(file)


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('excellon',
                        nargs = '?',
                        type = argparse.FileType('r'),
                        default = sys.stdin)

    # currently only suppress leading zeros is suppored
    parser.add_argument('-d', '--digits',
                        type = int,
                        default = 5,
                        help = 'number of decimal places in coordinates')

    parser.add_argument('-g', '--grid',
                        type = str,
                        default = '0.1',
                        help = 'grid size')
    
    parser.add_argument('-e', '--exclude-diameter',
                        type = str,
                        default = '0.012',
                        help = 'hole diameter excluded from checking, typically used for vias')

    args = parser.parse_args()

    excellon = Excellon(digits = args.digits, file = args.excellon)

    exclude_dia = Decimal(args.exclude_diameter)
    grid = Decimal(args.grid)

    for tool_num, tool in excellon.tools.items():
        # skip vias
        if tool.dia == exclude_dia:
            continue
        for coord in excellon.holes[tool_num]:
            x = coord.x
            y = coord.y
            if x % grid != 0 or y % grid != 0:
                print(f'dia {tool.dia}: ({x}, {y})')
            


if __name__ == '__main__':
    main()
